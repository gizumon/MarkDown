---
tag:
  - 学習メモ
  - 読書ログ
---

# Webを支える技術
----

# Agenda
* [ ] [ __Web技術__](#web技術)
* [ ] [ __Webの歴史__](#webの歴史)

---
---

# Web技術
1. HTTP
  * アプリケーションプロトコル
2. URI
  * リソース識別子
3. HTML
  * ハイパーメディアフォーマット

# Webの歴史
  * 1945 - Memex: 情報検索システムに関する論文
  * 196X - メインフレームの開発: ホストコンピュータを用いた集中処理
  * 1965 - ハイパーテキスト/メディア: 多様なメディアを相互リンクさせた概念
  * 1969 - ARPANET: 米国内の大学や研究期間をつなぐネットワーク
  * 1970 - コンピュータの小型化
  * 1987 - HyperCard: 初めて実用化されたカード(文章)を相互リンクシステム (Apple)
  * 1990 - Webの提案書: ハイパーメディアを用いた分散情報管理システム (Tim Berners-Lee)
  * 1993 - Mosaic: 文字 + 画像を用いたブラウザ (イリノイ大学 NCSA)
  * 1994 - W3Cの設立: 技術の標準化(HTML, XML, HTTP, URI, CSS)
  * 199X - Webの成功とAPI論争
  * 2000 - REST(Representational State Transfer)アーキテクチャスタイルの提唱(Roy Fielding)
  * 200X - Googleの検索エンジンの知名度が一定の地位に
  * 2002 - Amazon Web Service: 書籍, 商品情報などをWeb経由で取得可能に (SOAP/REST両APIを提供)
  * 2003 - SOAP vs REST 論争(SOAPではWS-＊で定められた複雑な仕様を利用する必要があったため次第に敬遠)
  
# RESTとは
* ネットワークシステムのwebアーキテクチャスタイル
* RESTはあくまで概念・思想
* 複数のアーキテクチャスタイルによって構成
## RESTを構成するアーキテクチャスタイル
### クライアント/サーバ  
  * リクエスト/レスポンスベースのシステム構成

### ステートレスサーバ
  * アプリケーションの状態をサーバで保持しない
  * ステートフルなシステム vs Cookieを使ったセッション管理

### キャッシュ
  * 一度サーバから取得したリソースをクライアントで使い回す
  * 通信を減らすことが可能
### 統一インターフェース
  * HTTP1.1て定義された8つのHTTPメソッドの利用

### 階層化システム
  * システム全体の階層化
  * 例：プロキシやロードバランサを階層に追加
    * HTTPとうい統一プロトコルのため、インターフェースが統一可能
### コードオンデマンド
  * Javascript/Flash/Javaアプレットの様にクライアント側でスクリプトが動作
  * つまりブラウザで動くスクリプト
  
## 2つのRESTの側面
### RESTとHYPERMEDIA
* 接続性：リソースをリンクで接続することで一つのアプリケーションを構成する
### RESTと分散システム
* RPC, CORBA, DCOMでは関数単位でサーバ呼び出しを行うため、オーバーヘッドが大きく性能劣化の原因となる
* また、改修時の相互影響が高い
* RESTでは統一インターフェイスであるため、互換性の問題が発生しない

# URI(Uniform Resource Identifier)
* リソースを識別するID
## URIの構文

```
http://blog.example.jp/entries/1
```

* URIスキーム：http
* ホスト名：blog.example.jp
* パス：/entries/1

```
http://yohei:pass@blog.example.jp:8000/search?q=test&debug=true#n10
```

* URIスキーム：http
* ユーザー情報：yohei:pass
* ホスト名：blog.example.jp
* ポート番号：8000
* パス：/search
* クエリパラメータ：q=test&debug=true
* URIフラグメント：#n10

# 3. HTTP
* TCP/IPのアプリケーション層プロトコル

### HTTP 0.9
* 1990年 Berners-Lee
* HTTP headerが存在しなかった

### HTTP 1.0
* 1996年 IETFで標準化
* HTTP headerの導入
* GET以外のメソッド追加

### HTTP 1.1
* 1999年
* チャンク転送、Acceptヘッダーの追加

## クライアント／サーバアーキテクチャ
### クライアント側
1. リクエストメッセージの構築
1. リクエストメッセージの送信
1. (待機)
1. レスポンスメッセージ受信
1. レスポンスメッセージ解析
1. クライアントの目的を達成するために必要な処理

### サーバー側
1. (待機)
1. リクエストメッセージの受信
1. リクエストメッセージの解析
1. 適切なアプリケーションプログラムへの処理委譲
1. アプリケーションプログラムから結果を取得
1. レスポンスメッセージの構築
1. レスポンスメッセージの送信

## アプリケーション状態
* `セッション`と呼ばれる
### ステートフルなアプリケーション
* アプリケーションの状態を持つ
* サーバー側で状態を持つため、スケーリングなどがしにくい
* クライアント数に応じてセッションの数が増加してしまう

### ステートレスなアプリケーション
* アプリケーションの状態を持たない
* 冗長になるが、クライアント側で必要な情報を持つため、スケーリング等に優れる
* `自己記述的(Self Descriptive)メッセージ`と呼ばれる
* クライアント側の送信データ量が増加する
* ネットワークトラブル時、処理が正常に行われたか確認ができない

## HTTPメソッド
* PUT: クライアント側がリソース位置を決める
* POST: サーバー側がリソース位置を決める

### 冪等性

|HTTPメソッド|性質|
|---|---|
|GET, HEAD|冪等かつ安全|
|PUT, DELETE|冪等だが安全でない|
|POST|冪等でも安全でもない|

* 冪等: ある操作を何回行っても結果が同じになること

## ステータスコード

|ステータスコード|内容|
|---|---|
|1XX|処理中|
|2XX|成功|
|3XX|リダイレクト|
|4XX|クライアントエラー|
|5XX|サーバーエラー|

## HTTPヘッダ
* 電子メールのメッセージヘッダから派生
### 日時
* リクエストとレスポンス
  * Date: GWTで記述。
* リクエスト
  * If-Modified-Since: 条件付きGETでリソースの更新日時を指定。
  * If-Unmodified-Since: 条件付きPUT, DELETEでリソースの更新日時を指定。
* レスポンス
  * Expired: レスポンスのキャッシュ期間
  * Last-Modified: リソースを最後に更新した日時
  * Retry-After: 再度リクエストを送る日時の目安

## MIME(Multipurpose Internet Mail Extensions)メディアタイプ
```
[タイプ]/[サブタイプ]
```
### タイプ, サブタイプの種類
* text/plain, csv, css, html, xml
* image/jpeg, png, gif
* audio
* video
* application/xml, xhtml+xml, json, pdf,zip
* multipart
* message
* model
* example

## コンテントネゴシエーション
* Accept : `クライアント`が処理できるメディアタイプを`サーバー`側へ伝える

```
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
```

* `q=`の値を`qvalue`と呼び、そのメディアタイプの優先順位を設定する  
* 上記の場合、text/html,application/xhtml+xmlがデフォルトの1、application/xmlが0.9、その他が0.8
* クライアントが指定したコンテントタイプにサーバーが対応していない場合、`406 Not Acceptable`が返る

* Accept-Charset: 処理できる文字コードを指定
* Accept-laguage: 処理できる言語コードを指定

## Content-lengthとチャンク転送
* Content-lengthでボディのサイズが分かる
* チャンク転送: ボディを分割して転送
  * ファイルサイズが決まるまでレスポンスを返せない
  * Transfer-Encodingヘッダーでチャンク送信指定可能

## 認証
* HTTPの認証方式
  * Basic認証
  * Digest認証
  * WSSE (WS-Security Extension)

```
HTTP/1.1 401 Unauthorized
WWWAuthenticate: Basic realm="Example.jp"
```

* realm(レルム): uri空間

### Basic認証
```
DELETE /test HTTP/1.1 
Host: example.jp
Authorization: Basic dXNlcjpwYXNzd29yZA==
```
* 簡単に複合されてしまう
* 通信路が暗号化されていないと危険

### Digest認証
```
HTTP/1.1 401 Unauthorized
WWWAuthenticate:Digestrealm="Example.jp",
nonce="1ac421d9e0a4k7q982z966p903372922",
qop="auth",
opaque="92eb5ffee6ae2fec3ad71c777531578f"
```
* Basic認証よりもセキュア
* 仕組み
  1. クライアントは認証なしでリクエスト
  2. 返ってきた401に含まれるヘッダ(チャレンジ)を使って次のリクエスト
    * nonce: 1度だけ使われる文字列(ランダム)
    * qop: 品質保証
      * `auth`か`auth-init`を指定
      * auth-initの場合、ボディの改竄も検知できる
    * opaque: クライアントには推測不可な文字列
  3. ダイジェストの生成と送信
    * ユーザー名：パスワードをMD5でハッシュ値変換
    * メソッド:uriをMD5でハッシュ値変換

# Restfulなサービスの設計
1. アドレス可能性
URIでリソースを一意に特定することができる性質
2. 接続性
リソースをリンクで接続し、1つのアプリケーションをなす技術
3. 統一インターフェース
GET/POST/PUT/DELETEなどHTTPの基本メソッドで統一されたインターフェースが使用されていること
4. ステートレス性
API側での状態管理がないこと、Cookieによるセッション管理など

## リソース指向アーキテクチャアプローチ
### 関係モデルからの導出
* 関係モデルのER図
* 中心となるリソースの導出
* リソースが持つデータの特定
* 検索結果リソースの導出
* 階層の検討
* トップレベルリソース
* リンクによる結合

## オブジェクト指向モデルからの導出
* 郵便番号のクラス図
* 主要データクラスからのリソース導出
* オブジェクトの操作結果リソース
* 階層の検討
* トップレベルリソース
* リンクによる結合

### 情報アーキテクチャからの導出
* 情報をわかりやすい伝え、受け手が情報を探しやすくする

